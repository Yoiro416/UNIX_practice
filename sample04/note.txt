  470 tty1     S      0:00 ./a.out
  471 tty1     Z      0:00 [a.out] <defunct>
  472 tty1     Z      0:00 [a.out] <defunct>
  473 tty1     Z      0:00 [a.out] <defunct>
  474 tty1     Z      0:00 [a.out] <defunct>
  475 tty1     Z      0:00 [a.out] <defunct>
  476 tty1     Z      0:00 [a.out] <defunct>
  495 tty2     S      0:00 grep --color=auto a.out


cを6回入力したあと、Eを入力する前にps -ax | grep a.outを実行し、リダイレクトした結果が以上のものだった。
この結果を見ると、入力した回数だけ<defunct>という表示のついたプロセスが存在していることがわかる。これは該当のプロセスがゾンビプロセスであることを示し、
これらのプロセスは既に実行されておらず、リソースも割り当てられていないものの依然としてPIDを保持している
この結果を取得した後、Eを入力し親プロセスを終了するとゾンビプロセスもすべて消えたため、親プロセスが終了すると子プロセスも自動的に削除されると予想した。

このような親と子のプロセス同士の関係について調べてみると、本来、子プロセスがexit()を呼び出し終了する場合は、親プロセスがwaitpid()を明示的に呼び出してexit値を取得する必要があり、
それでも今回の実行では最終的にゾンビプロセス含め終了していたのは、カーネルが親プロセス終了時に子のプロセスを取り込むためであるとわかった。

よって、ゾンビプロセスをpsコマンドによって我々が確認できるようになってしまう原因には
1.親プロセスがまだ生きているが
2.生成した子プロセスがexitし
3.親プロセスがwaitpidを明示的に呼び出していない
という3条件を満たす場合、もしくは
-カーネルがゾンビプロセスの自動回収に失敗した場合
の2通りの理由が考えられる。